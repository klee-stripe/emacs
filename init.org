-*- eval: (add-hook 'after-save-hook (lambda () (org-babel-tangle)) nil t) -*-

* Tangling Hook
  There are two main approaches to writing your emacs configuration in
  org-mode:
  - ~org-babel-load-file~. This approach is very simple to implement,
    but has to tangle each file when emacs starts.
  - ~org-babel-tangle~. This approach stores the tangled file on disk,
    but you have to remember to re-tangle after each edit.


  We can use a file-local after-save-hook to do the tangling
  automatically. However, this file variable is not considered safe by
  default, so emacs will prompt you the first time you open this
  file.

  #+BEGIN_SRC emacs-lisp :tangle yes
    (setq safe-local-variable-values '((eval add-hook 'after-save-hook
                                             (lambda nil (org-babel-tangle))
                                             nil t)))
  #+END_SRC
** Further Reading
   - https://www.reddit.com/r/emacs/comments/372nxd/
* [[https://github.com/raxod502/straight.el][straight.el]]
  #+BEGIN_SRC emacs-lisp :tangle yes
    (let ((bootstrap-file (concat user-emacs-directory "straight/bootstrap.el"))
          (bootstrap-version 2))
      (unless (file-exists-p bootstrap-file)
        (with-current-buffer
            (url-retrieve-synchronously
             "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
             'silent 'inhibit-cookies)
          (goto-char (point-max))
          (eval-print-last-sexp)))
      (load bootstrap-file nil 'nomessage))

    (setq use-package-always-ensure t)
    (straight-use-package 'use-package)
  #+END_SRC
* [[https://github.com/emacscollective/no-littering][no-littering]]
  This keeps files like ~projectile-known-projects-file~ where they
  belong.

  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package no-littering
      :demand t)
  #+END_SRC
* [[https://github.com/noctuid/general.el][general]]
  general provides a unified interface for binding keys. I use SPC and
  DEL as my leaders, since my keyboard puts them under my left and
  right thumbs.

  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package general
      :demand t
      :config
      (general-create-definer private/with-leader
                              :prefix "SPC"
                              :non-normal-prefix "M-SPC"
                              :states '(normal visual insert emacs))
      (general-create-definer private/with-local-leader
                              :prefix "DEL"
                              :non-normal-prefix "M-DEL"
                              :states '(normal visual insert emacs)))
  #+END_SRC
* [[https://github.com/emacs-evil/evil][evil]]
  I never really became fluent in vim, but my brief experience made it
  impossible to go back to any other editing system. The two big
  innovations of vim were:
  - separate modes for binding commands and inserting text
  - composable operators and text objects


  I'm not married to anything specific in vim or evil besides those
  two principles, but nothing really comes close, and I'm not in the
  mood to roll my own version of evil right now.

  My evil configuration makes extensive use of sequenced keypresses
  under a leader. I find excessive chording (ie pressing multiple keys
  simultaneously) to be a nightmare for my hands, and would much
  rather press 3-4 keys in a row than 2-3 at once.

  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package evil
      :demand t
      :diminish 'undo-tree-mode
      :init
      (setq evil-want-Y-yank-to-eol t)
      (setq evil-disable-insert-state-bindings t)
      :config
      (evil-mode t)
      :general
      (:states '(normal visual)
       ";" 'evil-ex
       "s" 'save-buffer
       "x" 'other-window
       "r" 'universal-argument)
      (:keymaps 'universal-argument-map
       "r" 'universal-argument-more)
      (private/with-leader
       "SPC" 'execute-extended-command
       ";" 'eval-expression
       "f" 'find-file
       "b" 'switch-buffer)
      (private/with-leader
       :infix "h"
       "h" 'help-for-help
       "f" 'describe-function
       "v" 'describe-variable
       "k" 'describe-key
       "m" 'describe-mode
       "w" 'where-is)
      (private/with-leader
       :infix "d"
       "h" 'split-window-vertically
       "v" 'split-window-horizontally
       "x" 'delete-window
       "k" 'kill-buffer-and-window))
  #+END_SRC
* [[https://github.com/abo-abo/swiper][ivy, counsel, swiper]]
  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package ivy
      :demand t
      :diminish 'ivy-mode
      :init
      (setq ivy-count-format "(%d/%d) ")
      :config
      (ivy-mode t)
      :general
      (:keymaps 'ivy-minibuffer-map
       "<escape>" 'abort-recursive-edit)
      ([remap switch-buffer] 'ivy-switch-buffer))
  #+END_SRC

  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package counsel
      :demand t
      :diminish 'counsel-mode
      :config
      (counsel-mode t))
  #+END_SRC

  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package ivy-hydra
      :commands (hydra-ivy/body))
  #+END_SRC

  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package swiper
      :general
      (private/with-leader
       "/" 'swiper))
  #+END_SRC

  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package wgrep
      :commands (wgrep-change-to-wgrep-mode)
      :init
      (setq wgrep-auto-save-buffer t)
      :general
      (:keymaps 'wgrep-mode-map
       [remap save-buffer] 'wgrep-finish-edit))
  #+END_SRC
* [[http://orgmode.org/][org]]
  Note that straight.el will always install a fresh org-mode from
  [[https://github.com/emacsmirror/org][emacsmirror]] (which, unlike org's ELPA, can be cloned over TLS). This
  repository is immense. We're waiting for [[https://github.com/raxod502/straight.el/issues/2][shallow clone]] support.

  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package org
      :init
      (setq org-M-RET-may-split-line nil)
      (setq org-blank-before-new-entry '((heading . nil)
                                         (plain-list-item . nil)))
      (setq org-catch-invisible-edits 'smart)
      (setq org-ellipsis "â¤µ")
      (setq org-src-fontify-natively t)
      (setq org-src-tab-acts-natively t)
      (setq org-src-window-setup 'current-window)
      (setq org-file-apps '(("pdf" . system)
                            (auto-mode . emacs)
                            (system . "xdg-open %s")
                            (t . system)))
      :general
      (:states '(insert emacs)
       :keymaps 'org-mode-map
       "RET" 'org-return-indent)
      (private/with-local-leader
       :keymaps 'org-mode-map
       "/" 'counsel-org-goto
       "r" 'org-reveal
       "RET" 'org-open-at-point
       "o" '(lambda (arg)
              (interactive "P")
              (end-of-line)
              (org-meta-return arg)
              (evil-append nil))
       "O" '(lambda (arg)
              (interactive "P")
              (beginning-of-line)
              (org-meta-return arg)
              (evil-append nil))))
  #+END_SRC
* General UI
  This is for built-in emacs miscellany that I want to reconfigure or
  turn off. There's quite a bit of stuff in here.

  #+BEGIN_SRC emacs-lisp :tangle yes
    (setq auto-save-default nil)
    (setq auto-save-list-file-prefix nil)
    (setq create-lockfiles nil)
    (setq make-backup-files nil)

    (setq initial-major-mode 'org-mode)
    (setq initial-scratch-message nil)

    (setq-default truncate-lines t)
    (setq visual-line-fringe-indicators '(left-curly-arrow nil))

    (setq echo-keystrokes 0.1)

    (setq sentence-end-double-space nil)

    (setq menu-bar-mode nil)
    (setq tool-bar-mode nil)

    (setq frame-title-format "%b")

    (setq save-interprogram-paste-before-kill t)

    (setq global-hl-line-sticky-flag t)
    (global-hl-line-mode t)
    (show-paren-mode t)

    (setq-default indent-tabs-mode nil)

    (add-hook 'after-save-hook 'executable-make-buffer-file-executable-if-script-p)
  #+END_SRC
* [[https://github.com/lewang/ws-butler][ws-butler]]
  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package ws-butler
      :demand t
      :diminish 'ws-butler-mode
      :init
      (setq ws-butler-keep-whitespace-before-point nil)
      :config
      (ws-butler-global-mode t))
  #+END_SRC
* [[https://github.com/bbatsov/projectile][projectile]] with [[https://github.com/ericdanan/counsel-projectile][ivy]] integration
  I mainly use projectile for fuzzy searching an entire project's
  files and buffers. Being able to ignore the distinction between
  files and buffers means one less thing to think about. Manually
  managing which files are open is unnecessary friction.

  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package projectile
      :demand t
      :config
      (projectile-mode t))
  #+END_SRC

  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package counsel-projectile
      :config
      (counsel-projectile-on)
      :general
      (private/with-leader
       :infix "p"
       "f" 'counsel-projectile
       "/" 'counsel-projectile-rg
       "p" 'counsel-projectile-switch-project))
  #+END_SRC
* [[https://github.com/abo-abo/avy][avy]]
  One of the unpleasant truths of vim is that, although there are
  structured motions for everything, you're probably going to start
  out by holding down hjkl a lot. It takes a long time for all those
  other motions to seep into your muscle memory. avy provides a
  command that quickly gets anywhere on the screen, regardless of how
  the buffer is formatted. It reflects a "lazy vim" approach of using
  cheap, general commands that you'll never have to think about.

  evil actually [[https://github.com/emacs-evil/evil/blob/master/evil-integration.el][defines]] motion wrappers for avy. However, its wrappers
  are inclusive, and I vastly prefer exclusivity for "jump to first
  instance" motions, so I redefine them.

  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package avy
      :init
      (setq avy-all-windows nil)
      :config
      (evil-define-avy-motion avy-goto-char-2-above exclusive)
      (evil-define-avy-motion avy-goto-char-2-below exclusive)
      :general
      (:states '(motion)
       "f" 'avy-goto-char-2-below
       "F" 'avy-goto-char-2-above))
  #+END_SRC

  - avy ~read-char~ prompts can only be canceled with C-g, can we use
    ESC?
  - quickly repeat last avy search in both directions?
  - similar bindings for t/T?
* [[https://github.com/abo-abo/ace-window][ace-window]]
  Forget obtuse up/down/left/right-based window switching. It takes up
  a ton of binding space and it's not even the fastest way to move
  around. With ace-window you can select any window with one key.

  I use a nasty hack to increase the size of the ace-window marker
  character. You can probably do this with ~custom-set-faces~, whose
  use I try to avoid.

  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package ace-window
      :init
      (setq aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l)
            aw-scope 'frame)
      :config
      (face-spec-set 'aw-leading-char-face
        '((((class color)) (:foreground "red" :height 3.0))
          (((background dark)) (:foreground "gray100" :height 3.0))
          (((background light)) (:foreground "gray0" :height 3.0))
          (t (:foreground "gray100" :underline nil :height 3.0))))
      :general
      ([remap other-window] 'ace-window))
  #+END_SRC
* [[https://github.com/wasamasa/shackle][shackle]]
  shackle keeps temporary windows out of the way. emacs has a nasty
  tendency to spawn them in the first free window it can find, and if
  you have your windows laid out just right, that's usually not what
  you wanted. I'm used to vim's "help pops up at the bottom" approach,
  and shackle lets me have that.

  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package shackle
      :demand t
      :diminish 'shackle-mode
      :init
      (setq shackle-rules '((help-mode :select t
                                       :popup t
                                       :align 'below
                                       :size 0.5)))
      :config
      (shackle-mode t))
  #+END_SRC
