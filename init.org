-*- eval: (add-hook 'after-save-hook (lambda () (org-babel-tangle)) nil t) -*-

* Tangling Hook
  There are two main approaches to writing your emacs configuration in
  org-mode:
  - org-babel-load-file. This approach is very simple to implement,
    but has to tangle each file when emacs starts.
  - org-babel-tangle. This approach stores the tangled file on disk,
    but you have to remember to re-tangle after each edit.


  We can use a file-local after-save-hook to do the tangling
  automatically. However, this file variable is not considered safe by
  default, so emacs will prompt you the first time you open this
  file.

  #+BEGIN_SRC emacs-lisp :tangle yes
    (setq safe-local-variable-values '((eval add-hook 'after-save-hook
                                             (lambda nil (org-babel-tangle))
                                             nil t)))
  #+END_SRC
** Further Reading
   - https://www.reddit.com/r/emacs/comments/372nxd/
* [[https://github.com/raxod502/straight.el][straight.el]]
  I like straight.el philosophically - clones and lockfiles "feels"
  like the right way to solve this problem - and I don't mind having
  to give up package.el for those benefits. Extensive documentation is
  also greatly appreciated.

  #+BEGIN_SRC emacs-lisp :tangle yes
    (let ((bootstrap-file (concat user-emacs-directory "straight/bootstrap.el"))
          (bootstrap-version 2))
      (unless (file-exists-p bootstrap-file)
        (with-current-buffer
            (url-retrieve-synchronously
             "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
             'silent 'inhibit-cookies)
          (goto-char (point-max))
          (eval-print-last-sexp)))
      (load bootstrap-file nil 'nomessage))

    (setq use-package-always-ensure t)
    (straight-use-package 'use-package)
  #+END_SRC
* [[https://github.com/emacscollective/no-littering][no-littering]]
  This keeps files like projectile-known-projects-file where they
  belong.

  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package no-littering
      :demand t)
  #+END_SRC
* [[https://github.com/noctuid/general.el][general]]
  general provides a unified interface for binding keys. I use ~SPC~
  and ~DEL~ as my leaders, since my keyboard puts them under my left
  and right thumbs.

  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package general
      :demand t
      :config
      (general-create-definer private/with-leader
                              :prefix "SPC"
                              :non-normal-prefix "M-SPC"
                              :states '(normal visual insert emacs))
      (general-create-definer private/with-local-leader
                              :prefix "DEL"
                              :non-normal-prefix "M-DEL"
                              :states '(normal visual insert emacs)))
  #+END_SRC
* [[https://github.com/emacs-evil/evil][evil]]
  I never really became fluent in vim, but my brief experience made it
  impossible to go back to any other editing system. The two big
  innovations of vim were:
  - separate modes for binding commands and inserting text
  - composable operators and text objects


  I'm not married to anything specific in vim or evil besides those
  two principles, but nothing really comes close, and I'm not in the
  mood to roll my own version of evil right now.

  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package evil
      :demand t
      :diminish 'undo-tree-mode
      :init
      (setq evil-want-Y-yank-to-eol t)
      (setq evil-disable-insert-state-bindings t)
      :config
      (evil-mode t)
      :general
      (:states '(normal visual)
       ";" 'evil-ex
       "s" 'save-buffer
       "x" 'other-window
       "r" 'universal-argument)
      (:keymaps 'universal-argument-map
       "r" 'universal-argument-more)
      (private/with-leader
       "SPC" 'execute-extended-command
       ";" 'eval-expression
       "f" 'find-file
       "b" 'switch-buffer)
      (private/with-leader
       :infix "h"
       "h" 'help-for-help
       "f" 'describe-function
       "v" 'describe-variable
       "k" 'describe-key
       "m" 'describe-mode
       "w" 'where-is)
      (private/with-leader
       :infix "d"
       "h" 'split-window-vertically
       "v" 'split-window-horizontally
       "x" 'delete-window
       "k" 'kill-buffer-and-window))
  #+END_SRC
* [[https://github.com/abo-abo/swiper][ivy, counsel, swiper]]
  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package ivy
      :demand t
      :diminish 'ivy-mode
      :init
      (setq ivy-count-format "(%d/%d) ")
      :config
      (ivy-mode t)
      :general
      (:keymaps 'ivy-minibuffer-map
       "<escape>" 'abort-recursive-edit)
      ([remap switch-buffer] 'ivy-switch-buffer))
  #+END_SRC

  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package counsel
      :demand t
      :diminish 'counsel-mode
      :config
      (counsel-mode t))
  #+END_SRC

  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package ivy-hydra
      :commands (hydra-ivy/body))
  #+END_SRC

  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package swiper
      :general
      (private/with-leader
       "/" 'swiper))
  #+END_SRC

  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package wgrep
      :commands (wgrep-change-to-wgrep-mode)
      :init
      (setq wgrep-auto-save-buffer t)
      :general
      (:keymaps 'wgrep-mode-map
       [remap save-buffer] 'wgrep-finish-edit))
  #+END_SRC
** TODO Structured Find/Replace
   This is a big topic, but I'm just going to stick it here because
   it's all going through ivy one way or another.
*** swiper
    swiper is my primary tool for structured find. It's incremental
    (ie it shows me where I'm going before I decide to go there) and
    ephemeral (ie if I dismiss the minibuffer it leaves no traces of
    its presence). One useful addition would be an easy way to resume
    the previous swiper search. ivy-resume, maybe?
*** isearch
    I have experimented with isearch (which is hooked into evil's ~/~
    by default). I find it most useful as a motion - ie when I already
    know exactly what I'm looking for with very high specificity - but
    avy works almost as well in those situations.

    I don't like using it for "searching". Jumping around with ~nN~ is
    cumbersome, and often after a few jumps you realize that you
    should have refined the search expression a bit more. With swiper,
    you can just scroll the minibuffer, and if you need to narrow it
    down, you can type in more text. I'm considering just binding
    swiper directly to ~/~.
*** occur/wgrep
    I find wgrep very useful for transitioning from search to replace.
    However, it takes multiple keybinds that I can never remember
    (first you have to occur from the minibuffer, then in the occur
    buffer you have to enable wgrep). I would like to abbreviate those
    bindings or make them less obscure.
*** rg
    There's probably some argument to be made for using rg (already
    projectile-integrated) in larger searches. We'll see where that
    fits into the picture. I just haven't used it enough yet. I
    believe the occur/wgrep system works just as well here as it does
    for swiper.
*** :s
    For smaller find/replaces, I still use vim's trusty ~:s~. The
    syntax of ~:s~ lets you write the find and replace halves of the
    expression simultaneously in a very nimble way. Automatically
    reusing the last pattern from ~/~ is also a nice feature, although
    a bit niche. I only feel the need to do that when I'm replacing a
    fairly complex pattern, which is usually a sign to reach for
    another tool.

    Once you start replacing a lot of stuff (more than a screenful) or
    really complicated stuff (anything involving eval-based
    expressions), ~:s~ becomes unpredictable and too cumbersome to use
    off hand. It works best when its effects are transparent and
    obvious.

    Speaking of transparency, evil's live preview for ~:s~ is
    extremely valuable. However, I've encountered some bugs with it
    (typically when replacing leading whitespace) where the
    preview markers don't go away after the command is done.

    It probably sounds like I like ~:s~ and I'm happy with its place
    in my workflow. For the most part, I am, but it's literally the
    only ex command I use regularly. If I can replace it with
    something else, that lets me completely rebind ~;:~ to other
    commands. visual-regexp, maybe? My requirements:
    - robust live preview
    - edit find and replace sides simultaneously, ideally with similar
      syntax to ~:s~
    - a quick keybind to jump from find to replace or vice versa
      (useful in longer expressions)
    - easy integration with swiper/rg and occur/wgrep, if you realize
      that you're biting off more than you can chew
*** iedit/multiple-cursors
    I've heard [[https://sam217pa.github.io/2016/09/11/nuclear-power-editing-via-ivy-and-ag/][good]] [[https://oremacs.com/2015/01/27/my-refactoring-workflow/][things]] about iedit/evil-iedit-state, and I'm also
    interested in multiple-cursors.
* [[http://orgmode.org/][org]]
  Note that straight.el will always install a fresh org-mode from
  [[https://github.com/emacsmirror/org][emacsmirror]] (which, unlike org's ELPA, can be cloned over TLS). This
  repository is immense. We're waiting for [[https://github.com/raxod502/straight.el/issues/2][shallow clone]] support.

  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package org
      :init
      (setq org-M-RET-may-split-line nil)
      (setq org-blank-before-new-entry '((heading . nil)
                                         (plain-list-item . nil)))
      (setq org-catch-invisible-edits 'smart)
      (setq org-ellipsis "â¤µ")
      (setq org-src-fontify-natively t)
      (setq org-src-tab-acts-natively t)
      (setq org-src-window-setup 'current-window)
      (setq org-file-apps '(("pdf" . system)
                            (auto-mode . emacs)
                            (system . "xdg-open %s")
                            (t . system)))
      :general
      (:states '(insert emacs)
       :keymaps 'org-mode-map
       "RET" 'org-return-indent)
      (private/with-local-leader
       :keymaps 'org-mode-map
       "/" 'counsel-org-goto
       "r" 'org-reveal
       "RET" 'org-open-at-point
       "o" '(lambda (arg)
              (interactive "P")
              (end-of-line)
              (org-meta-return arg)
              (evil-append nil))
       "O" '(lambda (arg)
              (interactive "P")
              (beginning-of-line)
              (org-meta-return arg)
              (evil-append nil))))
  #+END_SRC
** org Navigation
   I'm very fond of counsel-org-goto. It Just Works, which can't be
   said for some of the things I tried in the past.

   org has org-goto built-in. However, I despise org's "open another
   buffer and fumble around in here" approach to navigation. You can
   customize org-goto to use ivy (org-goto-interface and
   org-outline-complete-in-steps), but I found that it choked on
   headlines with slashes in them. Perhaps it was an ivy bug.

   Rather than investigate the slashes problem with org-goto, I
   tolerated counsel-imenu for a while. You need to futz around with
   some variables (imenu-auto-rescan, imenu-auto-rescan-timeout) to
   make it rescan every time you use it. The real problem is that it
   only displays leaf-level headings, so you can't jump directly to
   intermediate headings.

   I've also heard of some other options like deft, orgnav, and
   helm-org-rifle, but for now, counsel-org-goto is so close to my
   ideal implementation that I'm no longer shopping around. [[https://www.reddit.com/r/emacs/comments/4a4a8n/better_system_than_defthelmorgmode_to_manage_many/][See also]].
** TODO ace-link
   A more powerful alternative to org-open-at-point. This should open
   the link at point (if any), and otherwise select one avy-style.
** TODO worf Tree Mutation
   It's fine to use counsel-org-goto for large jumps, but for shorter
   movements, it's much faster to go up or down headings. worf has an
   especially elegant way of combining navigation and mutation of org
   trees. Unfortunately it doesn't play nice with evil.

   One important caveat of any up/down heading navigation is that it
   tends to pollute the jumplist. Ideally, you want to "enter" heading
   navigation mode, jump around headings freely, and add to the
   jumplist when you "exit" heading navigation mode. I used to have a
   hydra for this, and might rebuild it.
* Built-ins
  This is for built-in emacs miscellany that I want to reconfigure or
  turn off. There's quite a bit of stuff in here.

  #+BEGIN_SRC emacs-lisp :tangle yes
    (setq auto-save-default nil)
    (setq auto-save-list-file-prefix nil)
    (setq create-lockfiles nil)
    (setq make-backup-files nil)

    (setq initial-major-mode 'org-mode)
    (setq initial-scratch-message nil)

    (setq-default truncate-lines t)
    (setq visual-line-fringe-indicators '(left-curly-arrow nil))

    (setq echo-keystrokes 0.1)

    (setq sentence-end-double-space nil)

    (setq menu-bar-mode nil)
    (setq tool-bar-mode nil)

    (setq frame-title-format "%b")

    (setq save-interprogram-paste-before-kill t)

    (setq global-hl-line-sticky-flag t)
    (global-hl-line-mode t)
    (show-paren-mode t)

    (setq-default indent-tabs-mode nil)

    (add-hook 'after-save-hook 'executable-make-buffer-file-executable-if-script-p)
  #+END_SRC
** TODO visual-line-mode
   visual-line-mode is a built-in mode that truncates lines at word
   boundaries. adaptive-wrap-mode (GNU ELPA) extends it to also
   preserve leading indentation. I have not had positive experiences
   with this part of emacs:
   - [[https://github.com/abo-abo/swiper/issues/227][swiper, org, and visual-line-mode]] cause some very strange issues
     when used together
   - apparently it doesn't like [[https://github.com/brentonk/adaptive-wrap-vp][variable-width fonts]] ([[https://debbugs.gnu.org/cgi/bugreport.cgi?bug=15155][see also]])
   - apparently it doesn't like [[https://gist.github.com/tsavola/6222431][hard tabs]] either


   I consider hard-filling paragraphs to be an ugly implementation
   detail that my editor is supposed to render irrelevant. It doesn't
   help that auto-fill-mode is not applicable to everything I write.
   emacs is really not doing the job here.
** TODO Indentation
   You can see that I set indent-tabs-mode to nil by default. I really
   do not like setting indentation behavior in my config. I used to
   use vim-sleuth and it was magical. You never had to tell it
   anything; it just knew what the right settings were. That's what
   indentation configuration is supposed to feel like. I've heard that
   dtrt-indent can provide similar functionality for emacs.

   I haven't had to edit any "real" code in emacs yet, so remapping
   org-return-indent was sufficient for me, but I'd also like to look
   into electric-indent-mode or aggressive-indent-mode to do this
   automatically.
* [[https://github.com/lewang/ws-butler][ws-butler]]
  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package ws-butler
      :demand t
      :diminish 'ws-butler-mode
      :init
      (setq ws-butler-keep-whitespace-before-point nil)
      :config
      (ws-butler-global-mode t))
  #+END_SRC
* [[https://github.com/bbatsov/projectile][projectile]] with [[https://github.com/ericdanan/counsel-projectile][ivy]] integration
  I mainly use projectile for fuzzy searching an entire project's
  files and buffers. It's quite refreshing to never think about what
  files are "open" and which ones aren't. The concept of a "root"
  directory is also important for things like rg searching.

  A recent tweak to projectile's modeline causes immense UI lag, which
  is what the custom modeline snippet is for. See more [[https://github.com/bbatsov/projectile/issues/1183#issuecomment-335569547][here]].

  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package projectile
      :demand t
      :init
      (setq projectile-mode-line
            '(:eval (format " Projectile[%s]" (projectile-project-name))))
      :config
      (projectile-mode t))
  #+END_SRC

  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package counsel-projectile
      :config
      (counsel-projectile-on)
      :general
      (private/with-leader
       :infix "p"
       "f" 'counsel-projectile
       "/" 'counsel-projectile-rg
       "p" 'counsel-projectile-switch-project))
  #+END_SRC
* [[https://github.com/abo-abo/avy][avy]]
  One of the unpleasant truths of vim is that, although there are
  structured motions for everything, you're probably going to start
  out by holding down hjkl a lot. It takes a long time for all those
  other motions to seep into your muscle memory. avy provides a
  command that quickly gets anywhere on the screen, regardless of how
  the buffer is formatted. It reflects a "lazy vim" approach of using
  cheap, general commands that you'll never have to think about.

  evil actually [[https://github.com/emacs-evil/evil/blob/master/evil-integration.el][defines]] motion wrappers for avy. However, its wrappers
  are inclusive, and I vastly prefer exclusivity for "jump to first
  instance" motions, so I redefine them.

  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package avy
      :init
      (setq avy-all-windows nil)
      :config
      (evil-define-avy-motion avy-goto-char-2-above exclusive)
      (evil-define-avy-motion avy-goto-char-2-below exclusive)
      :general
      (:states '(motion)
       "f" 'avy-goto-char-2-below
       "F" 'avy-goto-char-2-above))
  #+END_SRC
** TODO read-char ~ESC~
   avy uses read-char to receive input. It seems I can only cancel it
   with ~C-g~. Is there really no way to use ~ESC~ or ~<escape>~
   instead?
** TODO Repeat
   One nice feature of vim-sneak is that, after your initial search,
   you can mash the key to go to the next or previous instance. Such
   behavior could also be useful here. It would be something like this:
   - when you first press ~fF~, you get prompted for the search
     argument (same as existing avy)
   - the matching candidates get highlighted under a trie (same as
     existing avy)
   - typing the keys for that candidate jumps you to it (same as
     existing avy)
   - after the first jump, mashing ~fF~ takes you to the next/previous
     instance of the same search argument
   - the jumplist only gets updated once for the entire search chain


   Look into evil-snipe, perhaps?
** TODO ~tT~
   If we have bindings for ~fF~, should we add ~tT~ as well? What
   would they do? We could also use ~ft~ instead of ~fF~, which is one
   less press of the shift key.

   While we're at it, maybe having separate keys for forward and
   backward is a waste of brain cycles, and we should just use
   avy-goto-char-2.
* [[https://github.com/abo-abo/ace-window][ace-window]]
  Forget obtuse up/down/left/right-based window switching. It takes up
  a ton of binding space and it's not even the fastest way to move
  around. ace-window lets you jump to any window with one key. You can
  hook into it to do a lot of other window-management-related things,
  but I use it for its barebones functionality, and it works like a
  charm.

  I use a nasty hack to increase the size of the ace-window marker
  character. You can probably do this with custom-set-faces, whose use
  I try to avoid.

  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package ace-window
      :init
      (setq aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l)
            aw-scope 'frame)
      :config
      (face-spec-set 'aw-leading-char-face
        '((((class color)) (:foreground "red" :height 3.0))
          (((background dark)) (:foreground "gray100" :height 3.0))
          (((background light)) (:foreground "gray0" :height 3.0))
          (t (:foreground "gray100" :underline nil :height 3.0))))
      :general
      ([remap other-window] 'ace-window))
  #+END_SRC
* [[https://github.com/wasamasa/shackle][shackle]]
  shackle keeps temporary windows out of the way. emacs has a nasty
  tendency to spawn them in the first free window it can find, and if
  you have your windows laid out just right, that's usually not what
  you wanted. I'm used to vim's "help pops up at the bottom" approach,
  and shackle lets me have that.

  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package shackle
      :demand t
      :diminish 'shackle-mode
      :init
      (setq shackle-rules '((help-mode :select t
                                       :popup t
                                       :align 'below
                                       :size 0.5)))
      :config
      (shackle-mode t))
  #+END_SRC
